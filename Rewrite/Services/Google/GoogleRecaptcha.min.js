const $=new NobyDa_Tools;function NobyDa_Tools(){this.isLoon="undefined"!=typeof $loon,this.isQuanX="undefined"!=typeof $configuration,this.isSurge="undefined"!=typeof $environment&&$environment["surge-version"],this.isNode="undefined"!=typeof module&&!!module.exports,this.http=Object.fromEntries(["GET","POST","PUT","DELETE","HEAD","OPTIONS","PATCH"].map(e=>[e.toLowerCase(),s=>this.isQuanX?new Promise((t,o)=>{$task.fetch({method:e,...s}).then(e=>t({status:e.statusCode,headers:e.headers,body:e.body}),e=>o(e.error))}):this.isSurge||this.isLoon||this.isNode?new Promise((t,o)=>{(this.isNode?require("request"):$httpClient)[e.toLowerCase()](s,(e,s,i)=>{e?o(e):t({status:s.status||s.statusCode,headers:s.headers,body:i})})}):void 0])),this.policy=(()=>this.isSurge?new Promise(e=>{$httpAPI("GET","v1/policies",null,s=>e({proxy:s.proxies,group:s["policy-groups"]}))}):this.isQuanX?new Promise(e=>{$configuration.sendMessage({action:"get_customized_policy"}).then(s=>e({proxy:Object.keys(s.ret).reduce((e,t)=>[...new Set([...e,...s.ret[t].candidates||[]])],[]).filter(e=>!s.ret[e]&&!["direct","proxy","reject"].includes(e)),group:Object.keys(s.ret)}),()=>e({}))}):this.isLoon?new Promise(async e=>{const s=JSON.parse($config.getConfig());e({proxy:(await Promise.all(s.all_policy_groups.map(e=>new Promise(s=>{$config.getSubPolicies(e,e=>{s(JSON.parse(e||"[]"))})})))).reduce((e,t)=>[...new Set([...e,...t.filter(e=>"node"==e.type&&!s.all_buildin_nodes.includes(e.name)).map(e=>e.name)])],[]),group:s.all_policy_groups})}):void 0),this.data=Object.fromEntries(["read","write"].map(e=>[e,(s,t)=>{if("write"===e){if(this.isSurge||this.isLoon)return $persistentStore.write(s,t);if(this.isQuanX)return $prefs.setValueForKey(s,t)}else if("read"===e){if(this.isSurge||this.isLoon)return $persistentStore.read(s);if(this.isQuanX)return $prefs.valueForKey(s)}}]))}$.ret={},(async()=>{if(200==($response.status||$response.statusCode))return;const e=JSON.parse(JSON.stringify($request)),s=await $.policy(),t="string"==typeof $argument&&$argument||$.data.read("GOOGLE_CAPTCHA_REGEX")||JSON.parse($.data.read("GOOGLE_CAPTCHA")||"{}").Regex||"",o=[...s.group,...s.proxy].filter(e=>e&&new RegExp(t).test(e)).sort(()=>Math.random()-.5).slice(0,20);console.log(`[INFO]: Use policy ${JSON.stringify(o,null,2)}`),await Promise.any([...o.map(s=>new Promise((t,o)=>{e.headers["User-Agent"]&&(e.headers.Cookie=`${Math.random()}`),e.headers["user-agent"]&&(e.headers.cookie=`${Math.random()}`),$.http[e.method.toLowerCase()]({policy:s,node:s,opts:{policy:s},...e}).then(e=>{200==e.status?t({policy:s,body:{...e,status:$.isQuanX?"HTTP/1.1 200":200}}):429==e.status?o(console.log(`[INFO]: Policy "${s}" need to CAPTCHA`)):o(console.log(`[INFO]: Policy "${s}" unknown resp status "${e.status}"`))}).catch(e=>o(console.log(`[ERROR]: ${e}`)))}))]).then(e=>{$.ret=e.body,console.log(`[INFO]: Use data from "${e.policy}"`)})})().catch(e=>console.log(`[ERROR]: ${e&&e.message||e}`)).finally(()=>$done($.ret));